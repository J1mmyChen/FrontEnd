(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{189:function(t,e,n){"use strict";n.r(e);var a=n(0),r=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{staticClass:"content"},[n("h3",{attrs:{id:"异步操作和async函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#异步操作和async函数","aria-hidden":"true"}},[t._v("#")]),t._v(" 异步操作和Async函数")]),n("p",[t._v("ES6之前的异步操作，大致以下四种：")]),n("ul",[n("li",[t._v("回调函数")]),n("li",[t._v("事件监听")]),n("li",[t._v("发布/订阅")]),n("li",[t._v("Promise对象")])]),n("p",[t._v("ES6将JavaScript异步编程带入了一个全新的阶段，ES7的Async函数更是提出了异步编程的终极解决方案。")]),n("blockquote",[n("p",[t._v("Generator函数是协程在ES6的实现，最大的特点就是可以交出函数的执行权（即暂停执行）。\n整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。")])]),n("blockquote",[n("p",[t._v("Generator函数的数据交换和错误处理。Generator函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。\n除此之外，它还有两个特性，使他可以作为异步编程的完整解决方案：")])]),n("ul",[n("li",[t._v("函数体内外的数据交换")]),n("li",[t._v("错误处理机制")])]),n("p",[t._v("ES6中的异步操作，(去掉了jQuery)[https://segmentfault.com/a/1190000003810652]，引入了许多前端框架。")])])}],!1,null,null,null);r.options.__file="Async.md";e.default=r.exports}}]);